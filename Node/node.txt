/**
 * Format Node
 *
 * Handles a single FormatOC node
 *
 * @author Chris Nasr <chris@ouroboroscoding.com>
 * @copyright Ouroboros Coding Inc.
 * @created 2022-03-19
 */

// Ouroboros
import { afindi, isObject, ucfirst } from '@ouroboros/tools';
import FNode from 'format-oc/Node';

// NPM modules
import PropTypes from 'prop-types';
import React from 'react';

// Material UI
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import Checkbox from '@mui/material/Checkbox';
import DialogTitle from '@mui/material/DialogTitle';
import DialogContent from '@mui/material/DialogContent';
import DialogActions from '@mui/material/DialogActions';
import Dialog from '@mui/material/Dialog';
import FormControl from '@mui/material/FormControl';
import FormControlLabel from '@mui/material/FormControlLabel';
import FormHelperText from '@mui/material/FormHelperText';
import InputAdornment from '@mui/material/InputAdornment';
import InputLabel from '@mui/material/InputLabel';
import Grid from '@mui/material/Grid';
import Select from '@mui/material/Select';
import TextField from '@mui/material/TextField';
import Typography from '@mui/material/Typography';

// React Phone Input
import PhoneInput from 'react-phone-input-material-ui'

// Format modules
import Child from './Child';
import { SelectBase } from './Shared';

/**
 * Node Multi Select CSV
 *
 * Handles values that are actually a list of comma seperated values
 *
 * @name NodeMultiSelectCSV
 * @access public
 * @extends NodeBase
 */
export class NodeMultiSelectCSV extends NodeBase {

	constructor(props) {

		// Call parent
		super(props);

		// If we have display options
		let lDisplayOptions = props.display.options;

		// If we got data
		if(lDisplayOptions) {

			// If the options are a dynamic SelectBase
			if(lDisplayOptions instanceof SelectBase) {
				this.callback = this.dynamicData.bind(this);

				// Get default data and add callback
				lDisplayOptions = lDisplayOptions.track(this.callback);
			}
		}
		// Else, get the options from the node
		else {
			lDisplayOptions = this.props.node.options().map(s => [s, s]);
		}

		// Set the state options
		this.state.defaultValues = null;
		this.state.options = lDisplayOptions;

		// Refs
		this.checks = [];

		// Bind methods
		this.cancel = this.cancel.bind(this);
		this.click = this.click.bind(this);
		this.submit = this.submit.bind(this);
	}

	cancel(event) {
		this.setState({defaultValues: null});
	}

	click(event) {
		this.setState({
			defaultValues: this.state.value.split(
				this.props.display.extra_space ? ', ' : ','
			)
		});
	}

	dynamicData(data) {
		this.setState({options: data});
	}

	submit(event) {

		// Init the values
		let lValues = [];

		// Go through each ref
		for(let i in this.checks) {
			if(this.checks[i].checked) {
				lValues.push(this.checks[i].value);
			}
		}

		// Combine the values
		let sValue = lValues.join(
			this.props.display.extra_space ? ', ' : ','
		);

		// Check the new value is valid
		let error = false;
		if(this.props.validation && !this.props.node.valid(sValue)) {
			error = 'Invalid Value';
		}

		// Update the state
		this.setState({
			defaultValues: null,
			error: error,
			value: sValue
		});

		// If there's a callback
		if(this.props.onChange) {
			this.props.onChange(sValue);
		}
	}

	render() {

		// Clear refs
		this.checks = [];

		// Initial props
		let props = {
			className: 'node_' + this.props.name,
			error: this.state.error !== false,
			helperText: this.state.error,
			readOnly: true,
			type: 'text',
			value: this.state.value === null ? '' : this.state.value,
			variant: this.props.variant,
			inputProps: {
				onClick:this.click,
				style:{cursor: 'pointer'}
			}
		}

		// If the label is a placeholder, add additional props
		if(this.props.label === 'placeholder') {
			props.label = this.props.display.title;
			props.placeholder = this.props.placeholder || this.props.display.title;
		} else if(this.props.placeholder) {
			props.placeholder = this.props.placeholder;
		}

		return (
			<React.Fragment>
				{this.props.label === 'above' &&
					<Typography>{this.props.display.title}</Typography>
				}
				<TextField {...props} />
				{this.state.defaultValues !== null &&
					<Dialog
						maxWidth="lg"
						onClose={this.cancel}
						open={true}
					>
					<DialogTitle>{this.props.display.title}</DialogTitle>
					<DialogContent dividers>
						<Grid container spacing={2}>
							{this.state.options.map(o =>
								<Grid item xs={12} md={4} lg={2} key={o[0]}>
									<FormControlLabel
										control={<Checkbox
													color="primary"
													defaultChecked={this.state.defaultValues.includes(o[0]) ? true : false}
													inputRef={ref => this.checks.push(ref)}
													inputProps={{
														value: o[0]
													}}
												/>}
										label={o[1]}
									/>
								</Grid>
							)}
						</Grid>
					</DialogContent>
					<DialogActions>
						<Button variant="contained" color="primary" onClick={this.submit}>
							Submit
						</Button>
					</DialogActions>
				</Dialog>
				}
			</React.Fragment>
		);
	}

	set options(data) {
		this.setState({options: data});
	}
}

// Register with Node
Node.register('multiselectcsv', NodeMultiSelectCSV);

/**
 * Node Number
 *
 * Handles values that represent numbers (ints, floats, decimal)
 *
 * @name NodeNumber
 * @access public
 * @extends NodeBase
 */
export class NodeNumber extends NodeBase {

	constructor(props) {
		super(props);
		this.change = this.change.bind(this);
	}

	change(event) {

		// Check the new value is valid
		let error = false;
		if(this.props.validation &&
			!this.props.node.valid(event.target.value === '' ? null : event.target.value)) {
			error = 'Invalid Value';
		}

		// Update the state
		this.setState({
			error: error,
			value: event.target.value
		});

		// If there's a callback
		if(this.props.onChange) {
			this.props.onChange(event.target.value);
		}
	}

	render() {

		// Initial input props
		let inputProps = {};
		let minmax = this.props.node.minmax();
		if(minmax.minimum) {
			inputProps.min = minmax.minimum;
		}
		if(minmax.maximum) {
			inputProps.max = minmax.maximum;
		}

		// Initial props
		let props = {
			className: 'node_' + this.props.name,
			error: this.state.error !== false,
			helperText: this.state.error,
			onKeyPress: this.keyPressed,
			onChange: this.change,
			type: 'number',
			value: this.state.value === null ? '' : this.state.value,
			variant: this.props.variant,
			inputProps: inputProps
		}

		// If the label is a placeholder
		if(this.props.label === 'placeholder') {
			props.label = this.props.display.title;
			props.placeholder = this.props.placeholder || this.props.display.title;
		} else if(this.props.placeholder) {
			props.placeholder = this.props.placeholder;
		}

		// Render
		return (
			<React.Fragment>
				{this.props.label === 'above' &&
					<Typography>{this.props.display.title}</Typography>
				}
				<TextField {...props} />
			</React.Fragment>
		);
	}
}

// Register with Node
Node.register('number', NodeNumber);

/**
 * Node Password
 *
 * Handles values that are strings or string-like
 *
 * @name NodePassword
 * @access public
 * @extends NodeBase
 */
export class NodePassword extends NodeBase {

	constructor(props) {
		super(props);

		// If there's a regex, override the node
		if('regex' in props.display) {
			props.node.regex(props.display.regex);
		}

		this.change = this.change.bind(this);
	}

	change(event) {

		// Check the new value is valid
		let error = false;
		if(this.props.validation && !this.props.node.valid(event.target.value)) {
			error = 'Invalid Value';
		}

		// Update the state
		this.setState({
			error: error,
			value: event.target.value
		});

		// If there's a callback
		if(this.props.onChange) {
			this.props.onChange(event.target.value);
		}
	}

	render() {

		// Initial props
		let props = {
			className: 'node_' + this.props.name,
			error: this.state.error !== false,
			helperText: this.state.error,
			onKeyPress: this.keyPressed,
			onChange: this.change,
			type: 'password',
			value: this.state.value === null ? '' : this.state.value,
			variant: this.props.variant,
		}

		// If the label is a placeholder, add additional props
		if(this.props.label === 'placeholder') {
			props.label = this.props.display.title;
			props.placeholder = this.props.placeholder || this.props.display.title;
		} else if(this.props.placeholder) {
			props.placeholder = this.props.placeholder;
		}

		// Render
		return (
			<React.Fragment>
				{this.props.label === 'above' &&
					<Typography>{this.props.display.title}</Typography>
				}
				<TextField {...props} />
			</React.Fragment>
		);
	}
}

// Register with Node
Node.register('password', NodePassword);

/**
 * Node Phone Number
 *
 * Handles values that are phone numbers
 *
 * @name NodePhoneNumber
 * @access public
 * @extends NodeBase
 */
export class NodePhoneNumber extends NodeBase {

	constructor(props) {
		super(props);
		this.change = this.change.bind(this);
	}

	change(value) {

		// Check the new value is valid
		let error = false;
		if(this.props.validation && !this.props.node.valid(value)) {
			error = 'Invalid Value';
		}

		// Update the state
		this.setState({
			error: error,
			value: value
		});

		// If there's a callback
		if(this.props.onChange) {
			this.props.onChange(value);
		}
	}

	render() {

		// Render
		return (
			<React.Fragment>
				{this.props.label === 'above' &&
					<Typography>{this.props.display.title}</Typography>
				}
				<FormControl className={'node_' + this.props.name} error={this.state.error !== false}>
					<PhoneInput
						component={TextField}
						label={this.props.display.title}
						onChange={this.change}
						onKeyPress={this.keyPressed}
						value={this.state.value === null ? '' : this.state.value}
						variant={this.props.variant}
					/>
					{this.state.error &&
						<FormHelperText>{this.state.error}</FormHelperText>
					}
				</FormControl>
			</React.Fragment>
		);
	}
}

// Register with Node
Node.register('phone_number', NodePhoneNumber);

/**
 * Node Price
 *
 * Handles values that represent numbers (ints, floats, decimal)
 *
 * @name NodePrice
 * @access public
 * @extends NodeBase
 */
export class NodePrice extends NodeBase {

	constructor(props) {
		super(props);
		this.change = this.change.bind(this);
	}

	change(event) {

		// Check the new value is valid
		let error = false;
		if(this.props.validation &&
			!this.props.node.valid(event.target.value === '' ? null : event.target.value)) {
			error = 'Invalid Value';
		}

		// Update the state
		this.setState({
			error: error,
			value: event.target.value
		});

		// If there's a callback
		if(this.props.onChange) {
			this.props.onChange(event.target.value);
		}
	}

	render() {

		// Initial input props
		let inputProps = {};
		let minmax = this.props.node.minmax();
		if(minmax.minimum) {
			inputProps.min = minmax.minimum;
		}
		if(minmax.maximum) {
			inputProps.max = minmax.maximum;
		}

		// Initial props
		let props = {
			className: 'node_' + this.props.name,
			error: this.state.error !== false,
			helperText: this.state.error,
			onKeyPress: this.keyPressed,
			onChange: this.change,
			type: 'number',
			value: this.state.value === null ? '' : this.state.value,
			variant: this.props.variant,
			inputProps: inputProps,
			InputProps: {
				startAdornment: <InputAdornment position="start">$</InputAdornment>,
			}
		}

		// If the label is a placeholder
		if(this.props.label === 'placeholder') {
			props.label = this.props.display.title;
			props.placeholder = this.props.placeholder || this.props.display.title;
		} else if(this.props.placeholder) {
			props.placeholder = this.props.placeholder;
		}

		// Render
		return (
			<React.Fragment>
				{this.props.label === 'above' &&
					<Typography>{this.props.display.title}</Typography>
				}
				<TextField {...props} />
			</React.Fragment>
		);
	}
}

// Register with Node
Node.register('price', NodePrice);

/**
 * Node Select
 *
 * Handles values that have specific options
 *
 * @name NodeSelect
 * @access public
 * @extends NodeBase
 */
export class NodeSelect extends NodeBase {

	constructor(props) {

		// Call parent
		super(props);

		// If we have display options
		let lDisplayOptions = props.display.options;

		// If we got data
		if(lDisplayOptions) {

			// If the options are a dynamic SelectBase
			if(lDisplayOptions instanceof SelectBase) {
				this.callback = this.dynamicData.bind(this);

				// Get default data and add callback
				lDisplayOptions = lDisplayOptions.track(this.callback);
			}

			// Else, if we have a list but the elements aren't lists
			else if(!(lDisplayOptions[0] instanceof Array)) {
				lDisplayOptions = lDisplayOptions.map(s => [s, s]);
			}
		}
		// Else, get the options from the node
		else {
			lDisplayOptions = this.props.node.options().map(s => [s, s]);
		}

		// Set the state options
		this.state.options = lDisplayOptions;

		// Bind methods
		this.change = this.change.bind(this);
	}

	componentWillUnmount() {
		// If there's a callback for dynamic options
		if(this.callback) {
			this.props.display.options.track(this.callback, true);
		}
	}

	dynamicData(data) {

		// Init the new state
		let oState = {options: data};

		// If the current value doesn't match the list
		if(afindi(data, 0, this.state.value) === -1) {
			oState.value = '';
		}

		// Set the new state
		this.setState(oState);
	}

	change(event) {

		// Check the new value is valid
		let error = false;
		if(this.props.validation &&
			!this.props.node.valid(event.target.value === '' ? null : event.target.value)) {
			error = 'Invalid Selection';
		}

		// Update the state
		this.setState({
			error: error,
			value: event.target.value
		});

		// If there's a callback
		if(this.props.onChange) {
			this.props.onChange(event.target.value);
		}
	}

	render() {

		// Init the option elements
		let lOpts = [<option key={0} value=''></option>];

		// Add the other options
		for(let i in this.state.options) {
			lOpts.push(<option key={1+i} value={this.state.options[i][0]}>{this.state.options[i][1]}</option>);
		}

		return (
			<React.Fragment>
				{this.props.label === 'above' &&
					<Typography>{this.props.display.title}</Typography>
				}
				<FormControl className={'node_' + this.props.name} error={this.state.error !== false} variant={this.props.variant}>
					{this.props.label === 'placeholder' &&
						<InputLabel id={this.props.name}>{this.props.display.title}</InputLabel>
					}
					<Select
						label={this.props.display.title}
						labelId={this.props.name}
						native
						onChange={this.change}
						value={this.state.value === null ? '' : this.state.value}
					>
						{lOpts}
					</Select>
					{this.state.error &&
						<FormHelperText>{this.state.error}</FormHelperText>
					}
				</FormControl>
			</React.Fragment>
		);
	}

	set options(data) {
		this.setState({options: data});
	}
}

// Register with Node
Node.register('select', NodeSelect);

/**
 * Node Text
 *
 * Handles values that are strings or string-like
 *
 * @name NodeText
 * @access public
 * @extends NodeBase
 */
export class NodeText extends NodeBase {

	constructor(props) {
		super(props);

		// If there's a regex, override the node
		if('regex' in props.display) {
			props.node.regex(props.display.regex);
		}

		this.change = this.change.bind(this);
	}

	change(event) {

		// Check the new value is valid
		let error = false;
		if(this.props.validation &&
			!this.props.node.valid(event.target.value === '' ? null : event.target.value)) {
			error = 'Invalid Value';
		}

		// Update the state
		this.setState({
			error: error,
			value: event.target.value
		});

		// If there's a callback
		if(this.props.onChange) {
			this.props.onChange(event.target.value);
		}
	}

	render() {

		// Initial inputProps
		let inputProps = {}
		let iDisplayMax = this.props.display.maximum;
		if(iDisplayMax) {
			inputProps.maxLength = iDisplayMax
		} else {
			let minmax = this.props.node.minmax();
			if(minmax.maximum) {
				inputProps.maxLength = minmax.maximum;
			}
		}

		// Initial props
		let props = {
			className: 'node_' + this.props.name,
			error: this.state.error !== false,
			helperText: this.state.error,
			onKeyPress: this.keyPressed,
			onChange: this.change,
			type: 'text',
			value: this.state.value === null ? '' : this.state.value,
			variant: this.props.variant,
			inputProps: inputProps
		}

		// If the label is a placeholder, add additional props
		if(this.props.label === 'placeholder') {
			props.label = this.props.display.title;
			props.placeholder = this.props.placeholder || this.props.display.title;
		} else if(this.props.placeholder) {
			props.placeholder = this.props.placeholder;
		}

		// Render
		return (
			<React.Fragment>
				{this.props.label === 'above' &&
					<Typography>{this.props.display.title}</Typography>
				}
				<TextField {...props} />
			</React.Fragment>
		);
	}
}

// Register with Node
Node.register('text', NodeText);

/**
 * Node TextArea
 *
 * Handles values that are strings or string-like over multiple lines
 *
 * @name NodeTextArea
 * @access public
 * @extends React.Component
 */
export class NodeTextArea extends React.Component {

	constructor(props) {
		super(props);

		this.state = {
			error: false,
			value: props.value
		}

		// If there's a regex, override the node
		if('regex' in props.display) {
			props.node.regex(props.display.regex);
		}

		this.change = this.change.bind(this);
	}

	change(event) {

		// Check the new value is valid
		let error = false;
		if(this.props.validation &&
			!this.props.node.valid(event.target.value === '' ? null : event.target.value)) {
			error = 'Invalid Value';
		}

		// Update the state
		this.setState({
			error: error,
			value: event.target.value
		});

		// If there's a callback
		if(this.props.onChange) {
			this.props.onChange(event.target.value);
		}
	}

	render() {

		// Initial props
		let props = {
			className: 'node_' + this.props.name,
			error: this.state.error !== false,
			helperText: this.state.error,
			onKeyPress: this.keyPressed,
			multiline: true,
			onChange: this.change,
			type: 'text',
			value: this.state.value === null ? '' : this.state.value,
			variant: this.props.variant
		}

		// If the label is a placeholder, add additional props
		if(this.props.label === 'placeholder') {
			props.label = this.props.display.title;
			props.placeholder = this.props.placeholder || this.props.display.title;
		} else if(this.props.placeholder) {
			props.placeholder = this.props.placeholder;
		}

		// If there's a max, add it to props
		let minmax = this.props.node.minmax();
		if(minmax.maximum) {
			props.inputProps = {maxLength: minmax.maximum};
		}

		// Render
		return (
			<React.Fragment>
				{this.props.label === 'above' &&
					<Typography>{this.props.display.title}</Typography>
				}
				<TextField {...props} />
			</React.Fragment>
		);
	}

	error(msg) {
		this.setState({"error": msg});
	}

	get value() {
		return this.state.value === '' ? null : this.state.value;
	}

	set value(val) {
		this.setState({"value": val});
	}
}

// Register with Node
Node.register('textarea', NodeTextArea);

/**
 * Node Time
 *
 * Handles values that represent a time
 *
 * @name NodeTime
 * @access public
 * @extends NodeBase
 */
export class NodeTime extends NodeBase {

	constructor(props) {
		super(props);
		this.change = this.change.bind(this);
	}

	change(event) {

		// Check the new value is valid
		let newTime = event.target.value + ':00';
		let error = false;

		if(this.props.validation && !this.props.node.valid(newTime)) {
			error = 'Invalid Time';
		}

		// Update the state
		this.setState({
			error: error,
			value: newTime
		});

		// If there's a callback
		if(this.props.onChange) {
			this.props.onChange(newTime);
		}
	}

	render() {

		// Initial props
		let props = {
			error: this.state.error !== false,
			helperText: this.state.error,
			onKeyPress: this.keyPressed,
			onChange: this.change,
			type: 'time',
			value: this.state.value === null ? '' : this.state.value,
			variant: this.props.variant
		}

		// If the label is a placeholder, add additional props
		if(this.props.label === 'placeholder') {
			props.label = this.props.display.title;
		}

		// Render
		return (
			<React.Fragment>
				{this.props.label === 'above' &&
					<Typography>{this.props.display.title}</Typography>
				}
				<TextField {...props} />
			</React.Fragment>
		);
	}
}

// Register with Node
Node.register('time', NodeTime);
